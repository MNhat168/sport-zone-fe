# GitHub Copilot Instructions for SportZone Frontend Project

## üéØ **Context**
You are working on SportZone Frontend - a React-based sports facility booking platform built with TypeScript, Vite, and modern React patterns following component-driven architecture.

## üèóÔ∏è **Architecture Guidelines**

### Follow React Component Architecture
- **Components**: Reusable UI components with TypeScript
- **Pages**: Route-level components that compose multiple components
- **Hooks**: Custom hooks for state logic and side effects  
- **Utils**: Pure utility functions and helpers
- **Types**: TypeScript interfaces and types

### Always Use TypeScript Patterns
```typescript
// ‚úÖ Component Interface
interface User {
    id: string;
    fullName: string;
    email: string;
    role: UserRole;
}

// ‚úÖ Component Props Interface
interface UserCardProps {
    user: User;
    onEdit?: (user: User) => void;
    onDelete?: (userId: string) => void;
}

// ‚úÖ React Component
const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
    return (
        <div className="user-card">
            <h3>{user.fullName}</h3>
            <p>{user.email}</p>
        </div>
    );
};
```

## üìù **Code Generation Rules**

### 1. React Components
- Always use TypeScript with proper interfaces
- Include JSDoc documentation with examples
- Use functional components with hooks
- Implement proper error handling and loading states

```tsx
import React, { useState, useEffect } from 'react';

interface User {
    id: string;
    fullName: string;
    email: string;
    role: string;
}

interface UserListProps {
    /**
     * Callback ƒë∆∞·ª£c g·ªçi khi ng∆∞·ªùi d√πng ƒë∆∞·ª£c ch·ªçn
     * @param user - Th√¥ng tin ng∆∞·ªùi d√πng ƒë∆∞·ª£c ch·ªçn
     */
    onUserSelect?: (user: User) => void;
    /**
     * C√≥ hi·ªÉn th·ªã actions kh√¥ng
     * @default true
     */
    showActions?: boolean;
}

/**
 * Component hi·ªÉn th·ªã danh s√°ch ng∆∞·ªùi d√πng
 * @param props - Props c·ªßa component
 * @returns JSX Element danh s√°ch ng∆∞·ªùi d√πng
 */
const UserList: React.FC<UserListProps> = ({ 
    onUserSelect, 
    showActions = true 
}) => {
    const [users, setUsers] = useState<User[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        fetchUsers();
    }, []);

    const fetchUsers = async () => {
        try {
            setLoading(true);
            const response = await fetch('/api/users');
            if (!response.ok) throw new Error('Failed to fetch users');
            const data = await response.json();
            setUsers(data);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Unknown error');
        } finally {
            setLoading(false);
        }
    };

    if (loading) return <div>ƒêang t·∫£i...</div>;
    if (error) return <div>L·ªói: {error}</div>;

    return (
        <div className="user-list">
            {users.map((user) => (
                <div key={user.id} className="user-item">
                    <h3>{user.fullName}</h3>
                    <p>{user.email}</p>
                    {showActions && (
                        <button onClick={() => onUserSelect?.(user)}>
                            Ch·ªçn
                        </button>
                    )}
                </div>
            ))}
        </div>
    );
};

export default UserList;
```

### 2. Custom Hooks
- Always async with proper error handling
- Include loading and error states
- Use TypeScript for all parameters and return types
- Implement proper cleanup for subscriptions/timers

```typescript
import { useState, useEffect, useCallback } from 'react';

interface User {
    id: string;
    fullName: string;
    email: string;
    role: string;
}

interface UseUsersOptions {
    autoFetch?: boolean;
    filter?: {
        name?: string;
        role?: string;
    };
}

interface UseUsersReturn {
    users: User[];
    loading: boolean;
    error: string | null;
    fetchUsers: () => Promise<void>;
    refetch: () => Promise<void>;
}

/**
 * Hook ƒë·ªÉ qu·∫£n l√Ω danh s√°ch ng∆∞·ªùi d√πng
 * @param options - T√πy ch·ªçn cho hook
 * @returns Object ch·ª©a users data v√† c√°c functions
 */
export const useUsers = (options: UseUsersOptions = {}): UseUsersReturn => {
    const { autoFetch = true, filter } = options;
    const [users, setUsers] = useState<User[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const fetchUsers = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            
            const queryParams = new URLSearchParams();
            if (filter?.name) queryParams.append('name', filter.name);
            if (filter?.role) queryParams.append('role', filter.role);
            
            const response = await fetch(`/api/users?${queryParams}`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            setUsers(data);
        } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Unknown error';
            setError(errorMessage);
            console.error('Error fetching users:', err);
        } finally {
            setLoading(false);
        }
    }, [filter]);

    useEffect(() => {
        if (autoFetch) {
            fetchUsers();
        }
    }, [autoFetch, fetchUsers]);

    const refetch = useCallback(() => fetchUsers(), [fetchUsers]);

    return {
        users,
        loading,
        error,
        fetchUsers,
        refetch
    };
};
```

### 3. TypeScript Types/Interfaces with Documentation
```typescript
/**
 * Enum cho vai tr√≤ ng∆∞·ªùi d√πng
 */
export enum UserRole {
    USER = 'user',
    COACH = 'coach',
    FIELD_OWNER = 'field_owner',
    ADMIN = 'admin'
}

/**
 * Interface cho th√¥ng tin ng∆∞·ªùi d√πng
 */
export interface User {
    /**
     * ID c·ªßa ng∆∞·ªùi d√πng
     * @example "507f1f77bcf86cd799439011"
     */
    id: string;
    
    /**
     * Email c·ªßa ng∆∞·ªùi d√πng
     * @example "john.doe@example.com"
     */
    email: string;
    
    /**
     * T√™n ƒë·∫ßy ƒë·ªß c·ªßa ng∆∞·ªùi d√πng
     * @example "John Doe"
     */
    fullName: string;
    
    /**
     * Vai tr√≤ c·ªßa ng∆∞·ªùi d√πng
     */
    role: UserRole;
    
    /**
     * Tr·∫°ng th√°i ho·∫°t ƒë·ªông
     * @default true
     */
    isActive: boolean;
    
    /**
     * Ng√†y t·∫°o t√†i kho·∫£n
     */
    createdAt: string;
    
    /**
     * Ng√†y c·∫≠p nh·∫≠t cu·ªëi
     */
    updatedAt: string;
}

/**
 * Interface cho form t·∫°o ng∆∞·ªùi d√πng m·ªõi
 */
export interface CreateUserForm {
    email: string;
    fullName: string;
    password: string;
    confirmPassword: string;
    role?: UserRole;
}

/**
 * Interface cho filter danh s√°ch ng∆∞·ªùi d√πng
 */
export interface UserFilter {
    /**
     * T√™n ƒë·ªÉ t√¨m ki·∫øm (partial match)
     */
    name?: string;
    
    /**
     * Vai tr√≤ ƒë·ªÉ filter
     */
    role?: UserRole;
    
    /**
     * Tr·∫°ng th√°i ho·∫°t ƒë·ªông
     */
    isActive?: boolean;
    
    /**
     * S·∫Øp x·∫øp theo field n√†o
     * @default "createdAt"
     */
    sortBy?: 'fullName' | 'email' | 'createdAt' | 'updatedAt';
    
    /**
     * Th·ª© t·ª± s·∫Øp x·∫øp
     * @default "desc"
     */
    sortOrder?: 'asc' | 'desc';
}

/**
 * Type cho API Response v·ªõi pagination
 */
export interface PaginatedResponse<T> {
    data: T[];
    pagination: {
        page: number;
        limit: number;
        total: number;
        totalPages: number;
    };
}

/**
 * Type utility ƒë·ªÉ t·∫°o partial types cho update forms
 */
export type UpdateUserForm = Partial<Pick<User, 'fullName' | 'email' | 'role' | 'isActive'>>;
```

## üîß **Naming Conventions**

- Components: `{Entity}` or `{Entity}{Purpose}` (e.g., `UserCard`, `UserList`, `BookingForm`)
- Pages: `{Entity}Page` (e.g., `UsersPage`, `BookingDetailsPage`)
- Hooks: `use{Entity}` or `use{Action}` (e.g., `useUsers`, `useAuth`, `useFetchUsers`)
- Utils: `{purpose}Utils` or `{entity}Helpers` (e.g., `dateUtils`, `validationHelpers`)
- Types/Interfaces: 
  - Entities: `{Entity}` (e.g., `User`, `Field`, `Booking`)
  - Props: `{Component}Props` (e.g., `UserCardProps`, `BookingFormProps`)
  - Form Data: `{Entity}Form` (e.g., `CreateUserForm`, `UpdateBookingForm`)
  - Filter: `{Entity}Filter` (e.g., `UserFilter`, `BookingFilter`)
  - API Response: `{Entity}Response` ho·∫∑c `PaginatedResponse<T>`
- Enums: `{EntityProperty}` (e.g., `UserRole`, `SportType`, `BookingStatus`)
- Constants: `UPPER_SNAKE_CASE` (e.g., `API_BASE_URL`, `DEFAULT_PAGE_SIZE`)
- Files: 
  - Components: `PascalCase.tsx` (e.g., `UserCard.tsx`)
  - Hooks: `camelCase.ts` (e.g., `useUsers.ts`)
  - Utils: `camelCase.ts` (e.g., `dateUtils.ts`)
  - Types: `camelCase.ts` (e.g., `userTypes.ts`)
- CSS Classes: `kebab-case` ho·∫∑c BEM (e.g., `user-card`, `user-card__title`)

## üìä **API Calling Patterns**

```typescript
// ‚úÖ Utility function cho API calls v·ªõi error handling
const apiClient = {
    baseURL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api',
    
    async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
        const url = `${this.baseURL}${endpoint}`;
        const config: RequestInit = {
            headers: {
                'Content-Type': 'application/json',
                ...options.headers,
            },
            ...options,
        };

        // Add auth token if available
        const token = localStorage.getItem('authToken');
        if (token) {
            config.headers = {
                ...config.headers,
                Authorization: `Bearer ${token}`,
            };
        }

        try {
            const response = await fetch(url, config);
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({ message: response.statusText }));
                throw new Error(error.message || `HTTP ${response.status}`);
            }

            return await response.json();
        } catch (error) {
            console.error(`API Error - ${endpoint}:`, error);
            throw error;
        }
    },

    // GET request
    get<T>(endpoint: string): Promise<T> {
        return this.request<T>(endpoint);
    },

    // POST request
    post<T>(endpoint: string, data?: any): Promise<T> {
        return this.request<T>(endpoint, {
            method: 'POST',
            body: data ? JSON.stringify(data) : undefined,
        });
    },

    // PUT request
    put<T>(endpoint: string, data?: any): Promise<T> {
        return this.request<T>(endpoint, {
            method: 'PUT',
            body: data ? JSON.stringify(data) : undefined,
        });
    },

    // DELETE request
    delete<T>(endpoint: string): Promise<T> {
        return this.request<T>(endpoint, {
            method: 'DELETE',
        });
    },
};

// ‚úÖ API service cho specific entity
export const userService = {
    async getUsers(filter?: UserFilter): Promise<PaginatedResponse<User>> {
        const params = new URLSearchParams();
        if (filter?.name) params.append('name', filter.name);
        if (filter?.role) params.append('role', filter.role);
        if (filter?.isActive !== undefined) params.append('isActive', String(filter.isActive));
        
        const queryString = params.toString();
        const endpoint = `/users${queryString ? `?${queryString}` : ''}`;
        
        return apiClient.get<PaginatedResponse<User>>(endpoint);
    },

    async getUserById(id: string): Promise<User> {
        return apiClient.get<User>(`/users/${id}`);
    },

    async createUser(userData: CreateUserForm): Promise<User> {
        return apiClient.post<User>('/users', userData);
    },

    async updateUser(id: string, userData: UpdateUserForm): Promise<User> {
        return apiClient.put<User>(`/users/${id}`, userData);
    },

    async deleteUser(id: string): Promise<void> {
        return apiClient.delete<void>(`/users/${id}`);
    },
};

// ‚úÖ React Query integration (n·∫øu s·ª≠ d·ª•ng React Query)
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

export const useUsersQuery = (filter?: UserFilter) => {
    return useQuery({
        queryKey: ['users', filter],
        queryFn: () => userService.getUsers(filter),
        staleTime: 5 * 60 * 1000, // 5 minutes
        cacheTime: 10 * 60 * 1000, // 10 minutes
    });
};

export const useCreateUser = () => {
    const queryClient = useQueryClient();
    
    return useMutation({
        mutationFn: userService.createUser,
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['users'] });
        },
    });
};
```

## üö´ **Don't Generate**

- Components without TypeScript interfaces for props
- Generic `any` types (use proper TypeScript types)
- API calls without error handling
- Components without proper loading/error states
- Code without JSDoc documentation
- Inline styles (use CSS classes or styled-components)
- Direct state mutations (use immutable updates)
- Components with mixed concerns (separate UI from business logic)
- Hardcoded API URLs (use environment variables)
- Forms without proper validation

## ‚úÖ **Always Include**

- Proper error handling with try-catch blocks
- Loading and error states in components
- TypeScript interfaces for props and state
- JSDoc documentation with examples
- Accessibility attributes (aria-labels, roles)
- Async/await for API calls
- Custom hooks for reusable logic
- Proper key props for lists
- Memoization for expensive computations (useMemo, useCallback)
- Environment variables for configuration

## üîç **Testing Patterns**

```typescript
import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { vi } from 'vitest';
import { UserList } from './UserList';
import { userService } from '../services/userService';

// Mock the service
vi.mock('../services/userService');
const mockUserService = userService as vi.Mocked<typeof userService>;

describe('UserList Component', () => {
    const mockUsers: User[] = [
        {
            id: '1',
            fullName: 'John Doe',
            email: 'john@example.com',
            role: UserRole.USER,
            isActive: true,
            createdAt: '2024-01-01',
            updatedAt: '2024-01-01',
        },
        {
            id: '2',
            fullName: 'Jane Smith',
            email: 'jane@example.com',
            role: UserRole.COACH,
            isActive: true,
            createdAt: '2024-01-01',
            updatedAt: '2024-01-01',
        },
    ];

    beforeEach(() => {
        vi.clearAllMocks();
    });

    it('should render loading state initially', () => {
        mockUserService.getUsers.mockImplementation(() => 
            new Promise(() => {}) // Never resolves
        );

        render(<UserList />);
        
        expect(screen.getByText('ƒêang t·∫£i...')).toBeInTheDocument();
    });

    it('should render users when loaded successfully', async () => {
        mockUserService.getUsers.mockResolvedValue({
            data: mockUsers,
            pagination: {
                page: 1,
                limit: 10,
                total: 2,
                totalPages: 1,
            },
        });

        render(<UserList />);

        await waitFor(() => {
            expect(screen.getByText('John Doe')).toBeInTheDocument();
            expect(screen.getByText('jane@example.com')).toBeInTheDocument();
        });

        expect(mockUserService.getUsers).toHaveBeenCalledTimes(1);
    });

    it('should render error state when fetch fails', async () => {
        const errorMessage = 'Failed to fetch users';
        mockUserService.getUsers.mockRejectedValue(new Error(errorMessage));

        render(<UserList />);

        await waitFor(() => {
            expect(screen.getByText(`L·ªói: ${errorMessage}`)).toBeInTheDocument();
        });
    });

    it('should call onUserSelect when user is clicked', async () => {
        const mockOnUserSelect = vi.fn();
        mockUserService.getUsers.mockResolvedValue({
            data: mockUsers,
            pagination: {
                page: 1,
                limit: 10,
                total: 2,
                totalPages: 1,
            },
        });

        render(<UserList onUserSelect={mockOnUserSelect} />);

        await waitFor(() => {
            expect(screen.getByText('John Doe')).toBeInTheDocument();
        });

        const selectButton = screen.getAllByText('Ch·ªçn')[0];
        fireEvent.click(selectButton);

        expect(mockOnUserSelect).toHaveBeenCalledWith(mockUsers[0]);
    });
});

// ‚úÖ Hook testing pattern
import { renderHook, waitFor } from '@testing-library/react';
import { useUsers } from './useUsers';

describe('useUsers Hook', () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });

    it('should fetch users on mount', async () => {
        mockUserService.getUsers.mockResolvedValue({
            data: mockUsers,
            pagination: {
                page: 1,
                limit: 10,
                total: 2,
                totalPages: 1,
            },
        });

        const { result } = renderHook(() => useUsers());

        expect(result.current.loading).toBe(true);

        await waitFor(() => {
            expect(result.current.loading).toBe(false);
        });

        expect(result.current.users).toEqual(mockUsers);
        expect(result.current.error).toBe(null);
        expect(mockUserService.getUsers).toHaveBeenCalledTimes(1);
    });

    it('should handle error state', async () => {
        const errorMessage = 'API Error';
        mockUserService.getUsers.mockRejectedValue(new Error(errorMessage));

        const { result } = renderHook(() => useUsers());

        await waitFor(() => {
            expect(result.current.loading).toBe(false);
        });

        expect(result.current.error).toBe(errorMessage);
        expect(result.current.users).toEqual([]);
    });
});
```

## üìã **File Structure**

When creating new features, organize files as:
```
src/features/{entity}/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ {Entity}List.tsx
‚îÇ   ‚îú‚îÄ‚îÄ {Entity}Card.tsx
‚îÇ   ‚îú‚îÄ‚îÄ {Entity}Form.tsx
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ use{Entity}.ts
‚îÇ   ‚îú‚îÄ‚îÄ use{Entity}Form.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ {entity}Service.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ {entity}Types.ts
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ {entity}Utils.ts
‚îî‚îÄ‚îÄ {Entity}Page.tsx
```

### Example for Users feature:
```
src/features/users/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ UserList.tsx
‚îÇ   ‚îú‚îÄ‚îÄ UserCard.tsx
‚îÇ   ‚îú‚îÄ‚îÄ UserForm.tsx
‚îÇ   ‚îú‚îÄ‚îÄ UserProfile.tsx
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useUsers.ts
‚îÇ   ‚îú‚îÄ‚îÄ useUserForm.ts
‚îÇ   ‚îú‚îÄ‚îÄ useUserProfile.ts
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ userService.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ userTypes.ts
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ userUtils.ts
‚îî‚îÄ‚îÄ UsersPage.tsx
```

### Alternative shared structure:
```
src/
‚îú‚îÄ‚îÄ components/          # Reusable UI components
‚îÇ   ‚îú‚îÄ‚îÄ ui/             # Basic UI components (Button, Input, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ common/         # Business logic components
‚îú‚îÄ‚îÄ pages/              # Route-level pages
‚îú‚îÄ‚îÄ hooks/              # Custom hooks
‚îú‚îÄ‚îÄ services/           # API services
‚îú‚îÄ‚îÄ types/              # TypeScript types
‚îú‚îÄ‚îÄ utils/              # Utility functions
‚îú‚îÄ‚îÄ store/              # State management (Redux, Zustand, etc.)
‚îî‚îÄ‚îÄ styles/             # Global styles
```

## üö´ **Terminal Command Restrictions**

**DO NOT suggest or run terminal commands automatically**, especially:
- ‚ùå `npm start` ho·∫∑c `npm run dev` ho·∫∑c `yarn dev`
- ‚ùå `vite` ho·∫∑c `vite dev`
- ‚ùå `npm run build` 
- ‚ùå Any auto-generated build/test/run commands

**ONLY suggest installation commands when explicitly needed:**
- ‚úÖ `npm install <package>` 
- ‚úÖ `pnpm install <package>`
- ‚úÖ `yarn add <package>`
- ‚úÖ `npm install` or `pnpm install` (for dependency installation)

**Reason**: The user prefers to manually run application commands and only wants assistance with dependency installation.

---

**Remember**: Follow these patterns consistently for all code generation in the SportZone Frontend project!